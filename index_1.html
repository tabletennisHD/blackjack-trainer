<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blackjack Basic Strategy Trainer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
const { useState, useEffect } = React;


const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

const BASIC_STRATEGY = {
  hard: {
    21: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    20: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    19: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    18: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    17: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    16: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    15: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    14: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    13: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    12: { 2: 'H', 3: 'H', 4: 'S', 5: 'S', 6: 'S', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    11: { 2: 'D', 3: 'D', 4: 'D', 5: 'D', 6: 'D', 7: 'D', 8: 'D', 9: 'D', 10: 'D', 'A': 'D' },
    10: { 2: 'D', 3: 'D', 4: 'D', 5: 'D', 6: 'D', 7: 'D', 8: 'D', 9: 'D', 10: 'H', 'A': 'H' },
    9:  { 2: 'H', 3: 'D', 4: 'D', 5: 'D', 6: 'D', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    8:  { 2: 'H', 3: 'H', 4: 'H', 5: 'H', 6: 'H', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    7:  { 2: 'H', 3: 'H', 4: 'H', 5: 'H', 6: 'H', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    6:  { 2: 'H', 3: 'H', 4: 'H', 5: 'H', 6: 'H', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    5:  { 2: 'H', 3: 'H', 4: 'H', 5: 'H', 6: 'H', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    4:  { 2: 'H', 3: 'H', 4: 'H', 5: 'H', 6: 'H', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
  },
  soft: {
    21: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    20: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    19: { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'D', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    18: { 2: 'D', 3: 'D', 4: 'D', 5: 'D', 6: 'D', 7: 'S', 8: 'S', 9: 'H', 10: 'H', 'A': 'H' },
    17: { 2: 'H', 3: 'D', 4: 'D', 5: 'D', 6: 'D', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    16: { 2: 'H', 3: 'H', 4: 'H', 5: 'D', 6: 'D', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    15: { 2: 'H', 3: 'H', 4: 'H', 5: 'D', 6: 'D', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    14: { 2: 'H', 3: 'H', 4: 'H', 5: 'H', 6: 'D', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    13: { 2: 'H', 3: 'H', 4: 'H', 5: 'D', 6: 'D', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
  },
  pair: {
    'A,A': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'P', 8: 'P', 9: 'P', 10: 'P', 'A': 'P' },
    '10,10': { 2: 'S', 3: 'S', 4: 'S', 5: 'S', 6: 'S', 7: 'S', 8: 'S', 9: 'S', 10: 'S', 'A': 'S' },
    '9,9': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'S', 8: 'P', 9: 'P', 10: 'S', 'A': 'S' },
    '8,8': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'P', 8: 'P', 9: 'P', 10: 'P', 'A': 'P' },
    '7,7': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'P', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    '6,6': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    '5,5': { 2: 'D', 3: 'D', 4: 'D', 5: 'D', 6: 'D', 7: 'D', 8: 'D', 9: 'D', 10: 'H', 'A': 'H' },
    '4,4': { 2: 'H', 3: 'H', 4: 'H', 5: 'P', 6: 'P', 7: 'H', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    '3,3': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'P', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
    '2,2': { 2: 'P', 3: 'P', 4: 'P', 5: 'P', 6: 'P', 7: 'P', 8: 'H', 9: 'H', 10: 'H', 'A': 'H' },
  }
};

const ACTION_NAMES = {
  'H': 'Hit',
  'S': 'Stand',
  'D': 'Double',
  'P': 'Split',
};

function BlackjackTrainer() {
  const [playerHand, setPlayerHand] = useState([]);
  const [dealerHand, setDealerHand] = useState([]);
  const [correctAction, setCorrectAction] = useState('');
  const [feedback, setFeedback] = useState('');
  const [stats, setStats] = useState({ correct: 0, total: 0 });
  const [showChart, setShowChart] = useState(false);
  const [showChat, setShowChat] = useState(false);
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [isLoadingChat, setIsLoadingChat] = useState(false);
  const [gamePhase, setGamePhase] = useState('betting');
  const [handResult, setHandResult] = useState('');
  const [decisionFeedback, setDecisionFeedback] = useState([]);

  // Split state
  const [splitHands, setSplitHands] = useState(null);      // [{cards, decisions}, {cards, decisions}]
  const [activeSplitIdx, setActiveSplitIdx] = useState(0); // which split hand we're playing
  
  // Detect if we're on mobile or if API likely won't work
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  const getCardValue = (rank) => {
    if (rank === 'A') return 11;
    if (['J', 'Q', 'K'].includes(rank)) return 10;
    return parseInt(rank);
  };

  const generateRandomCard = () => {
    const rank = RANKS[Math.floor(Math.random() * RANKS.length)];
    const suit = SUITS[Math.floor(Math.random() * SUITS.length)];
    return { rank, suit, value: getCardValue(rank) };
  };

  const calculateHandValue = (hand) => {
    let total = 0;
    let aces = 0;
    
    hand.forEach(card => {
      if (card.rank === 'A') {
        aces += 1;
        total += 11;
      } else {
        total += card.value;
      }
    });
    
    while (total > 21 && aces > 0) {
      total -= 10;
      aces -= 1;
    }
    
    return total;
  };

  const isSoftHand = (hand) => {
    const hasAce = hand.some(card => card.rank === 'A');
    if (!hasAce) return false;
    // A hand is soft if counting one ace as 11 doesn't bust it
    let total = 0;
    let aces = 0;
    hand.forEach(card => {
      if (card.rank === 'A') { aces++; total += 11; }
      else total += card.value;
    });
    // Reduce aces as needed
    while (total > 21 && aces > 0) { total -= 10; aces--; }
    // Soft means at least one ace is still counting as 11 (i.e. we didn't reduce all aces)
    const acesUsedAs11 = hand.filter(c => c.rank === 'A').length - (hand.filter(c => c.rank === 'A').length - aces);
    return aces > 0 && total <= 21;
  };

  const getCorrectAction = (playerCards, dealerHand) => {
    const dealerUpcard = dealerHand[0];
    // Normalize J, Q, K to '10' for strategy lookup
    const dealerRank = ['J', 'Q', 'K'].includes(dealerUpcard.rank) ? '10' : dealerUpcard.rank;
    
    if (playerCards.length === 2 && playerCards[0].rank === playerCards[1].rank) {
      // Normalize pair rank too (J/Q/K all treated as 10,10)
      const r1 = ['J', 'Q', 'K'].includes(playerCards[0].rank) ? '10' : playerCards[0].rank;
      const r2 = ['J', 'Q', 'K'].includes(playerCards[1].rank) ? '10' : playerCards[1].rank;
      const pairKey = `${r1},${r2}`;
      if (BASIC_STRATEGY.pair[pairKey]) {
        return BASIC_STRATEGY.pair[pairKey][dealerRank];
      }
    }
    
    if (isSoftHand(playerCards)) {
      const total = calculateHandValue(playerCards);
      if (BASIC_STRATEGY.soft[total]) {
        return BASIC_STRATEGY.soft[total][dealerRank];
      }
    }
    
    const total = calculateHandValue(playerCards);
    return BASIC_STRATEGY.hard[total]?.[dealerRank] || 'H';
  };

  const getExplanation = (playerCards, dealerHand, action, isCorrect) => {
    const dealerUpcard = dealerHand[0];
    // Normalize J, Q, K to '10' for strategy lookup
    const dealerRank = ['J', 'Q', 'K'].includes(dealerUpcard.rank) ? '10' : dealerUpcard.rank;
    const total = calculateHandValue(playerCards);
    const isSoft = isSoftHand(playerCards);
    const isPair = playerCards.length === 2 && playerCards[0].rank === playerCards[1].rank;
    
    let explanation = '';
    
    if (isPair) {
      const rank = playerCards[0].rank;
      if (rank === 'A' || rank === '8') {
        explanation = `Always split ${rank}s. ${rank === 'A' ? 'Two chances at 21 is better than one hand of 12.' : 'Splitting 8s turns a bad 16 into two potentially strong hands.'}`;
      } else if (rank === '10' || rank === 'J' || rank === 'Q' || rank === 'K') {
        explanation = `Never split 10s. You already have 20, which is an excellent hand.`;
      } else if (rank === '5') {
        explanation = `Never split 5s. You have 10, which is a great doubling hand.`;
      } else if (rank === '9') {
        if (dealerRank === '7' || dealerRank === '10' || dealerRank === 'A') {
          explanation = `Stand with pair of 9s vs dealer ${dealerRank}. You have 18, which is solid.`;
        } else {
          explanation = `Split 9s vs dealer ${dealerRank}. The dealer is likely to bust.`;
        }
      } else {
        if (['2', '3', '4', '5', '6'].includes(dealerRank)) {
          explanation = `Split vs weak dealer ${dealerRank}. Build two strong hands.`;
        } else {
          explanation = `Hit vs dealer ${dealerRank}. Too strong to split.`;
        }
      }
    } else if (isSoft) {
      if (total >= 19) {
        explanation = `Stand on soft ${total}. Strong hand.`;
      } else if (total === 18) {
        if (['9', '10', 'A'].includes(dealerRank)) {
          explanation = `Hit soft 18 vs dealer ${dealerRank}. 18 isn't good enough, and you can't bust.`;
        } else if (['3', '4', '5', '6'].includes(dealerRank)) {
          explanation = `Double soft 18 vs weak dealer ${dealerRank}. Maximize profit.`;
        } else {
          explanation = `Stand on soft 18 vs dealer ${dealerRank}. Decent hand.`;
        }
      } else {
        if (['4', '5', '6'].includes(dealerRank)) {
          explanation = `Double soft ${total} vs dealer ${dealerRank}. Can't bust, dealer is weak.`;
        } else {
          explanation = `Hit soft ${total}. Can't bust, keep improving.`;
        }
      }
    } else {
      if (total >= 17) {
        if (total === 16 && ['9', '10', 'A'].includes(dealerRank)) {
          explanation = `Hit 16 vs dealer ${dealerRank}. You're in a tough spot â€” you'll bust often, but the dealer is too strong to stand.`;
        } else if (total === 15 && dealerRank === '10') {
          explanation = `Hit 15 vs dealer 10. You're an underdog either way, but hitting gives you a chance to improve.`;
        } else {
          explanation = `Stand on hard ${total}. High bust risk if you hit.`;
        }
      } else if (total === 12) {
        if (['4', '5', '6'].includes(dealerRank)) {
          explanation = `Stand on 12 vs dealer ${dealerRank}. Dealer likely to bust.`;
        } else {
          explanation = `Hit 12 vs dealer ${dealerRank}. Need to improve.`;
        }
      } else if (total === 11) {
        explanation = `Always double on 11. Can't bust, great chance at 21.`;
      } else if (total === 10) {
        if (dealerRank === '10' || dealerRank === 'A') {
          explanation = `Hit on 10 vs dealer ${dealerRank}. Dealer too strong to double.`;
        } else {
          explanation = `Double on 10 vs dealer ${dealerRank}. Great chance at 20.`;
        }
      } else if (total === 9) {
        if (['3', '4', '5', '6'].includes(dealerRank)) {
          explanation = `Double on 9 vs dealer ${dealerRank}. Profitable long-term.`;
        } else {
          explanation = `Hit on 9 vs dealer ${dealerRank}. Dealer too strong to double.`;
        }
      } else if (total <= 8) {
        explanation = `Always hit on ${total}. Can't bust, must improve.`;
      } else {
        if (['2', '3', '4', '5', '6'].includes(dealerRank)) {
          explanation = `Stand on ${total} vs dealer ${dealerRank}. Dealer likely to bust.`;
        } else {
          explanation = `Hit on ${total} vs dealer ${dealerRank}. Weak hand, dealer is strong.`;
        }
      }
    }
    
    if (!isCorrect) {
      return `âœ— Incorrect. You chose ${ACTION_NAMES[action]}, but you should ${ACTION_NAMES[correctAction]}. ${explanation}`;
    } else {
      return `âœ“ Correct! ${explanation}`;
    }
  };

  const handleChatSubmit = async () => {
    if (!chatInput.trim() || isLoadingChat) return;

    const userMessage = chatInput.trim();
    setChatInput('');
    setChatMessages(prev => [...prev, { role: 'user', content: userMessage }]);
    setIsLoadingChat(true);

    try {
      const handContext = `
Current hand context:
- Player's cards: ${playerHand.map(c => `${c.rank}${c.suit}`).join(', ')} (Total: ${calculateHandValue(playerHand)}${isSoftHand(playerHand) ? ' - Soft' : ''})
- Dealer showing: ${dealerHand[0].rank}${dealerHand[0].suit}${gamePhase !== 'player' ? ` (Full hand: ${dealerHand.map(c => `${c.rank}${c.suit}`).join(', ')}, Total: ${calculateHandValue(dealerHand)})` : ' (hole card hidden)'}
- Game phase: ${gamePhase}
${playerHand.length === 2 ? `- Correct basic strategy action: ${ACTION_NAMES[correctAction]}` : ''}
${playerHand.length === 2 && playerHand[0].rank === playerHand[1].rank ? `- This is a pair of ${playerHand[0].rank}s` : ''}
      `.trim();

      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1000,
          messages: [
            {
              role: "user",
              content: `You're a veteran Vegas blackjack dealer with 20+ years at the tables. You know basic strategy cold and you've seen it all. You're gruff, no-nonsense, but you've got a soft spot for players who want to learn the right way to play. You don't suffer fools, but you respect people who ask good questions and want to improve.

Your personality:
- Direct and straight-shooting. No sugar-coating.
- Dry humor and occasional sarcasm, but never mean-spirited
- You call it "the book" when referring to basic strategy
- You use casino lingo naturally ("the house," "stiff hands," "bust cards," "pat hands")
- Short, punchy answers â€” you're busy running a table
- You occasionally drop in colorful Vegas dealer wisdom
- You're impressed when someone makes the right play, annoyed when they don't listen to the book

${handContext}

Rules for this game: 6-deck shoe, dealer stands on soft 17, double after split allowed.

Player's question: ${userMessage}

Answer in character as the dealer. Keep it concise but educational. If they're asking about the current hand, tell them what the book says and why. Call out bad plays directly. Acknowledge good plays with grudging respect.`
            }
          ],
        })
      });

      const data = await response.json();
      
      // Check for API errors
      if (data.error) {
        setChatMessages(prev => [...prev, { 
          role: 'assistant', 
          content: `API Error: ${data.error.message}. The AI chat feature requires running in Claude.ai to work properly.` 
        }]);
        return;
      }
      
      const assistantMessage = data.content?.find(block => block.type === 'text')?.text || 'Sorry, I could not generate a response.';
      
      setChatMessages(prev => [...prev, { role: 'assistant', content: assistantMessage }]);
    } catch (error) {
      setChatMessages(prev => [...prev, { 
        role: 'assistant', 
        content: 'Sorry, I encountered an error. Please try again.' 
      }]);
    } finally {
      setIsLoadingChat(false);
    }
  };

  const dealNewHand = () => {
    const player = [generateRandomCard(), generateRandomCard()];
    const dealer = [generateRandomCard(), generateRandomCard()];
    
    setPlayerHand(player);
    setDealerHand(dealer);
    setGamePhase('player');
    setFeedback('');
    setHandResult('');
    setDecisionFeedback([]);
    setSplitHands(null);
    setActiveSplitIdx(0);
    
    if (calculateHandValue(player) === 21) {
      if (calculateHandValue(dealer) === 21) {
        setHandResult('push');
        setGamePhase('complete');
        setFeedback('Push! Both you and the dealer have blackjack.');
      } else {
        setHandResult('blackjack');
        setGamePhase('complete');
        setFeedback('âœ“ Blackjack! You win 3:2.');
      }
    } else {
      setCorrectAction(getCorrectAction(player, dealer));
    }
  };

  // Resolve dealer and build final summary across one or more hands
  const resolveDealer = (hands) => {
    let dealerCards = [...dealerHand];
    while (calculateHandValue(dealerCards) < 17) {
      dealerCards.push(generateRandomCard());
    }
    setDealerHand(dealerCards);
    const dealerTotal = calculateHandValue(dealerCards);

    const outcomes = hands.map(({ cards }) => {
      const total = calculateHandValue(cards);
      if (total > 21) return 'Busted';
      if (dealerTotal > 21) return `Win (dealer busted)`;
      if (total > dealerTotal) return `Win (${total} vs ${dealerTotal})`;
      if (total < dealerTotal) return `Lose (${total} vs ${dealerTotal})`;
      return `Push (${total})`;
    });

    const dealerLine = dealerTotal > 21
      ? `Dealer busted with ${dealerTotal}.`
      : `Dealer stands on ${dealerTotal}.`;

    let summary = `**Hand Outcome:** ${dealerLine}\n\n`;

    if (hands.length > 1) {
      hands.forEach(({ decisions }, i) => {
        summary += `**Hand ${i + 1}:** ${outcomes[i]}\n`;
        decisions.forEach((d, j) => {
          summary += `  ${j + 1}. ${d.handState} â†’ ${d.action} ${d.correct ? 'âœ“' : 'âœ—'}\n`;
        });
      });
    } else {
      summary += `**Result:** ${outcomes[0]}\n\n`;
      if (hands[0].decisions.length > 0) {
        summary += `**Your Decisions:**\n`;
        hands[0].decisions.forEach((d, j) => {
          summary += `${j + 1}. ${d.handState} â†’ ${d.action} ${d.correct ? 'âœ“' : 'âœ—'}\n`;
        });
      }
    }

    setFeedback(summary);
    setGamePhase('complete');
  };

  // Get current active hand cards
  const activeCards = () => splitHands ? splitHands[activeSplitIdx].cards : playerHand;

  // Update active hand cards (split or normal)
  const updateActiveCards = (newCards, callback) => {
    if (splitHands) {
      const updated = splitHands.map((h, i) =>
        i === activeSplitIdx ? { ...h, cards: newCards } : h
      );
      setSplitHands(updated);
      if (callback) callback(updated);
    } else {
      setPlayerHand(newCards);
      if (callback) callback(null);
    }
  };

  // Record a decision against current active hand
  const recordDecision = (record) => {
    if (splitHands) {
      const updated = splitHands.map((h, i) =>
        i === activeSplitIdx ? { ...h, decisions: [...h.decisions, record] } : h
      );
      setSplitHands(updated);
      return updated;
    } else {
      const updated = [...decisionFeedback, record];
      setDecisionFeedback(updated);
      return null;
    }
  };

  const handleHit = (currentDecisions) => {
    const current = activeCards();
    const newCard = generateRandomCard();
    const newHand = [...current, newCard];

    const newTotal = calculateHandValue(newHand);

    if (splitHands) {
      const updatedHands = splitHands.map((h, i) =>
        i === activeSplitIdx ? { ...h, cards: newHand } : h
      );

      if (newTotal > 21) {
        // This split hand busted â€” move to next or resolve
        advanceSplitOrResolve(updatedHands, activeSplitIdx);
      } else if (newTotal === 21) {
        advanceSplitOrResolve(updatedHands, activeSplitIdx);
      } else {
        setSplitHands(updatedHands);
        setPlayerHand(newHand);
        setCorrectAction(getCorrectAction(newHand, dealerHand));
      }
    } else {
      setPlayerHand(newHand);
      if (newTotal > 21) {
        const decisions = currentDecisions || decisionFeedback;
        let summary = `**Hand Outcome:** You busted with ${newTotal}! Dealer wins.\n\n`;
        if (decisions.length > 0) {
          summary += `**Your Decisions:**\n`;
          decisions.forEach((d, j) => {
            summary += `${j + 1}. ${d.handState} â†’ ${d.action} ${d.correct ? 'âœ“' : 'âœ—'}\n`;
          });
        }
        setFeedback(summary);
        setGamePhase('complete');
      } else if (newTotal === 21) {
        handleStand(newHand, currentDecisions);
      } else {
        setCorrectAction(getCorrectAction(newHand, dealerHand));
      }
    }
  };

  const advanceSplitOrResolve = (updatedHands, doneIdx) => {
    const nextIdx = doneIdx + 1;
    if (nextIdx < updatedHands.length) {
      // Move to next split hand
      setSplitHands(updatedHands);
      setActiveSplitIdx(nextIdx);
      const nextCards = updatedHands[nextIdx].cards;
      setPlayerHand(nextCards);
      setCorrectAction(getCorrectAction(nextCards, dealerHand));
      setFeedback('');
    } else {
      // All split hands done â€” resolve dealer
      setSplitHands(updatedHands);
      resolveDealer(updatedHands);
    }
  };

  const handleStand = (hand, currentDecisions) => {
    const standHand = hand || activeCards();

    if (splitHands) {
      const updatedHands = splitHands.map((h, i) =>
        i === activeSplitIdx ? { ...h, cards: standHand } : h
      );
      advanceSplitOrResolve(updatedHands, activeSplitIdx);
    } else {
      setGamePhase('dealer');
      const decisions = currentDecisions || decisionFeedback;
      let dealerCards = [...dealerHand];
      while (calculateHandValue(dealerCards) < 17) {
        dealerCards.push(generateRandomCard());
      }
      setDealerHand(dealerCards);

      const playerTotal = calculateHandValue(standHand);
      const dealerTotal = calculateHandValue(dealerCards);

      let outcomeMessage = '';
      if (dealerTotal > 21) { setHandResult('win'); outcomeMessage = `Dealer busted with ${dealerTotal}! You win.`; }
      else if (playerTotal > dealerTotal) { setHandResult('win'); outcomeMessage = `You win! Your ${playerTotal} beats dealer's ${dealerTotal}.`; }
      else if (playerTotal < dealerTotal) { setHandResult('lose'); outcomeMessage = `Dealer wins with ${dealerTotal} vs your ${playerTotal}.`; }
      else { setHandResult('push'); outcomeMessage = `Push! Both have ${playerTotal}.`; }

      let summary = `**Hand Outcome:** ${outcomeMessage}\n\n`;
      if (decisions.length > 0) {
        summary += `**Your Decisions:**\n`;
        decisions.forEach((d, j) => {
          summary += `${j + 1}. ${d.handState} â†’ ${d.action} ${d.correct ? 'âœ“' : 'âœ—'}\n`;
        });
      }
      setFeedback(summary);
      setGamePhase('complete');
    }
  };

  const handleDouble = (currentDecisions) => {
    const current = activeCards();
    const newCard = generateRandomCard();
    const newHand = [...current, newCard];
    const newTotal = calculateHandValue(newHand);

    if (splitHands) {
      const updatedHands = splitHands.map((h, i) =>
        i === activeSplitIdx ? { ...h, cards: newHand } : h
      );
      // After doubling, always move to stand/next
      advanceSplitOrResolve(updatedHands, activeSplitIdx);
    } else {
      setPlayerHand(newHand);
      if (newTotal > 21) {
        const decisions = currentDecisions || decisionFeedback;
        let summary = `**Hand Outcome:** You busted with ${newTotal} after doubling! Dealer wins.\n\n`;
        if (decisions.length > 0) {
          summary += `**Your Decisions:**\n`;
          decisions.forEach((d, j) => {
            summary += `${j + 1}. ${d.handState} â†’ ${d.action} ${d.correct ? 'âœ“' : 'âœ—'}\n`;
          });
        }
        setFeedback(summary);
        setGamePhase('complete');
      } else {
        handleStand(newHand, currentDecisions);
      }
    }
  };

  const handleSplit = (currentDecisions) => {
    const card = playerHand[0]; // Both cards are same rank
    const hand1 = [card, generateRandomCard()];
    const hand2 = [playerHand[1], generateRandomCard()];

    // Special case: split aces only get one card each (already handled by auto-stand after 2 cards)
    const isAceSplit = card.rank === 'A';

    const hands = [
      { cards: hand1, decisions: currentDecisions || [], isAceSplit },
      { cards: hand2, decisions: [], isAceSplit },
    ];

    setSplitHands(hands);
    setActiveSplitIdx(0);
    setPlayerHand(hand1);
    setFeedback('');

    if (isAceSplit) {
      // Aces get exactly one card â€” auto-advance both hands directly to dealer
      const hands2 = [
        { cards: hand1, decisions: currentDecisions || [], isAceSplit: true },
        { cards: hand2, decisions: [], isAceSplit: true },
      ];
      setTimeout(() => resolveDealer(hands2), 300);
    } else {
      setCorrectAction(getCorrectAction(hand1, dealerHand));
    }
  };

  const handleAction = (action) => {
    const isCorrect = action === correctAction;
    const current = activeCards();
    const currentTotal = calculateHandValue(current);
    
    const explanation = getExplanation(current, dealerHand, action, isCorrect);
    
    const decisionRecord = {
      action: ACTION_NAMES[action],
      correct: isCorrect,
      explanation: explanation,
      handState: `${current.map(c => `${c.rank}${c.suit}`).join(', ')} (${currentTotal})`,
    };

    // Record decision and get updated list
    let updatedDecisions;
    if (splitHands) {
      const updated = splitHands.map((h, i) =>
        i === activeSplitIdx ? { ...h, decisions: [...h.decisions, decisionRecord] } : h
      );
      setSplitHands(updated);
      updatedDecisions = updated[activeSplitIdx].decisions;
    } else {
      updatedDecisions = [...decisionFeedback, decisionRecord];
      setDecisionFeedback(updatedDecisions);
    }

    setStats(prev => ({
      correct: prev.correct + (isCorrect ? 1 : 0),
      total: prev.total + 1
    }));

    // Pause on first-decision mistakes
    if (!isCorrect && current.length === 2 && !splitHands) {
      setFeedback(explanation);
      return;
    }

    switch (action) {
      case 'H': handleHit(updatedDecisions); break;
      case 'S': handleStand(null, updatedDecisions); break;
      case 'D':
        if (current.length === 2) { handleDouble(updatedDecisions); }
        else { setFeedback('You can only double on your first action.'); }
        break;
      case 'P':
        if (current.length === 2) { handleSplit(updatedDecisions); }
        else { setFeedback('You can only split on your first action.'); }
        break;
    }
  };

  useEffect(() => {
    dealNewHand();
  }, []);

  const accuracy = stats.total > 0 ? Math.round((stats.correct / stats.total) * 100) : 0;

  return (
    <div className="min-h-screen bg-gradient-to-br from-green-800 via-green-700 to-green-900 p-8">
      <div className="max-w-4xl mx-auto">
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold text-white mb-2">Blackjack Basic Strategy Trainer</h1>
          <p className="text-green-200">6-Deck, S17, Double After Split</p>
        </div>

        {showChart && (
          <div className="bg-white rounded-lg p-4 mb-6 text-sm">
            <h3 className="font-bold mb-2">Quick Reference</h3>
            <p className="text-gray-600 mb-2">H=Hit, S=Stand, D=Double, P=Split</p>
            <p className="text-gray-600">The trainer will test you on all decision scenarios. Keep practicing!</p>
          </div>
        )}

        <div className="bg-white/95 backdrop-blur rounded-lg p-8 shadow-2xl">
          <div className="mb-8">
            <h2 className="text-lg font-semibold mb-3 text-gray-700">Dealer's Hand:</h2>
            <div className="flex justify-center gap-4">
              {dealerHand.map((card, idx) => (
                <div key={idx}>
                  {idx === 0 || gamePhase !== 'player' ? (
                    <div className={`w-24 h-32 rounded-lg border-2 flex flex-col items-center justify-center text-3xl font-bold ${
                      card.suit === 'â™¥' || card.suit === 'â™¦' ? 'text-red-600 border-red-600' : 'text-black border-black'
                    } bg-white shadow-lg`}>
                      <div>{card.rank}</div>
                      <div className="text-4xl">{card.suit}</div>
                    </div>
                  ) : (
                    <div className="w-24 h-32 rounded-lg border-2 border-blue-600 bg-blue-600 shadow-lg flex items-center justify-center">
                      <div className="text-white text-4xl">ðŸ‚ </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
            {gamePhase !== 'player' && (
              <div className="text-center text-gray-700 font-semibold mt-2">
                Total: {calculateHandValue(dealerHand)}
              </div>
            )}
          </div>

          {/* Player Hand(s) */}
          {splitHands ? (
            <div className="mb-8">
              <h2 className="text-lg font-semibold mb-3 text-gray-700">Your Hands:</h2>
              <div className="flex justify-center gap-8">
                {splitHands.map((hand, handIdx) => (
                  <div key={handIdx} className={`p-3 rounded-xl border-2 ${
                    handIdx === activeSplitIdx && gamePhase === 'player'
                      ? 'border-yellow-400 bg-yellow-50 shadow-lg'
                      : 'border-gray-200 bg-gray-50'
                  }`}>
                    <div className="text-xs font-bold text-center mb-2 uppercase tracking-wide text-gray-500">
                      Hand {handIdx + 1} {handIdx === activeSplitIdx && gamePhase === 'player' ? 'â–¶ Active' : ''}
                    </div>
                    <div className="flex gap-2 mb-2">
                      {hand.cards.map((card, idx) => (
                        <div key={idx} className={`w-16 h-22 rounded-lg border-2 flex flex-col items-center justify-center text-xl font-bold py-3 px-2 ${
                          card.suit === 'â™¥' || card.suit === 'â™¦' ? 'text-red-600 border-red-400' : 'text-black border-gray-400'
                        } bg-white shadow`}>
                          <div>{card.rank}</div>
                          <div className="text-2xl">{card.suit}</div>
                        </div>
                      ))}
                    </div>
                    <div className="text-center text-sm font-semibold text-gray-700">
                      {calculateHandValue(hand.cards)}
                      {isSoftHand(hand.cards) && <span className="text-green-600 ml-1">(Soft)</span>}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ) : (
            <div className="mb-8">
              <h2 className="text-lg font-semibold mb-3 text-gray-700">Your Hand:</h2>
              <div className="flex justify-center gap-4 mb-4">
                {playerHand.map((card, idx) => (
                  <div key={idx} className={`w-24 h-32 rounded-lg border-2 flex flex-col items-center justify-center text-3xl font-bold ${
                    card.suit === 'â™¥' || card.suit === 'â™¦' ? 'text-red-600 border-red-600' : 'text-black border-black'
                  } bg-white shadow-lg`}>
                    <div>{card.rank}</div>
                    <div className="text-4xl">{card.suit}</div>
                  </div>
                ))}
              </div>
              <div className="text-center text-gray-700 font-semibold">
                Total: {calculateHandValue(playerHand)}
                {isSoftHand(playerHand) && <span className="text-green-600 ml-2">(Soft)</span>}
              </div>
            </div>
          )}

          {gamePhase === 'player' && (
            <div className="mb-6">
              <h2 className="text-lg font-semibold mb-3 text-gray-700 text-center">What should you do?</h2>
              <div className="flex flex-wrap justify-center gap-3">
                <button
                  onClick={() => handleAction('H')}
                  disabled={feedback.startsWith('âœ—')}
                  className="px-8 py-3 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white font-semibold rounded-lg transition shadow-lg"
                >
                  Hit
                </button>
                <button
                  onClick={() => handleAction('S')}
                  disabled={feedback.startsWith('âœ—')}
                  className="px-8 py-3 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white font-semibold rounded-lg transition shadow-lg"
                >
                  Stand
                </button>
                <button
                  onClick={() => handleAction('D')}
                  disabled={feedback.startsWith('âœ—') || activeCards().length > 2}
                  className="px-8 py-3 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-400 text-white font-semibold rounded-lg transition shadow-lg"
                >
                  Double
                </button>
                <button
                  onClick={() => handleAction('P')}
                  disabled={feedback.startsWith('âœ—') || activeCards().length > 2 || !!splitHands}
                  className="px-8 py-3 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 text-white font-semibold rounded-lg transition shadow-lg"
                >
                  Split
                </button>
              </div>
            </div>
          )}

          {/* Decision tracker â€” shows per-split-hand decisions or normal decisions */}
          {gamePhase !== 'complete' && (
            splitHands ? (
              splitHands.some(h => h.decisions.length > 0) && (
                <div className="mb-4">
                  <h3 className="text-sm font-semibold text-gray-600 mb-2">Your Decisions This Hand:</h3>
                  {splitHands.map((hand, hi) => hand.decisions.length > 0 && (
                    <div key={hi} className="mb-2">
                      <div className="text-xs font-bold text-gray-500 mb-1">Hand {hi + 1}</div>
                      <div className="space-y-1">
                        {hand.decisions.map((d, di) => (
                          <div key={di} className={`text-sm p-2 rounded ${d.correct ? 'bg-green-50 text-green-800' : 'bg-red-50 text-red-800'}`}>
                            <span className="font-medium">{d.handState}</span> â†’ {d.action} {d.correct ? 'âœ“' : 'âœ—'}
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              )
            ) : (
              decisionFeedback.length > 0 && (
                <div className="mb-4">
                  <h3 className="text-sm font-semibold text-gray-600 mb-2">Your Decisions This Hand:</h3>
                  <div className="space-y-1">
                    {decisionFeedback.map((decision, idx) => (
                      <div key={idx} className={`text-sm p-2 rounded ${decision.correct ? 'bg-green-50 text-green-800' : 'bg-red-50 text-red-800'}`}>
                        <span className="font-medium">{decision.handState}</span> â†’ {decision.action} {decision.correct ? 'âœ“' : 'âœ—'}
                      </div>
                    ))}
                  </div>
                </div>
              )
            )
          )}

          {feedback && (
            <div className={`p-4 rounded-lg text-base leading-relaxed whitespace-pre-wrap ${
              feedback.startsWith('âœ“') || feedback.includes('win') ? 'bg-green-100 text-green-800' : 
              feedback.startsWith('âœ—') ? 'bg-red-100 text-red-800' :
              'bg-blue-100 text-blue-800'
            }`}>
              {feedback}
            </div>
          )}

          {(gamePhase === 'complete' || feedback.startsWith('âœ—')) && (
            <div className="text-center mt-4">
              <button
                onClick={dealNewHand}
                className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition"
              >
                Next Hand
              </button>
            </div>
          )}
        </div>

        {/* Stats and Controls Bar */}
        <div className="bg-white/10 backdrop-blur rounded-lg p-4 mt-6 flex justify-between items-center">
          <div className="text-white">
            <span className="text-2xl font-bold">{stats.correct}</span>
            <span className="text-green-200"> / {stats.total}</span>
            <span className="ml-4 text-xl">({accuracy}%)</span>
          </div>
          <div className="flex gap-2">
            <button
              onClick={() => setShowChat(!showChat)}
              className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded transition"
            >
              {showChat ? 'Hide' : 'Ask Dealer'}
            </button>
            <button
              onClick={() => setShowChart(!showChart)}
              className="px-4 py-2 bg-white/20 hover:bg-white/30 text-white rounded transition"
            >
              {showChart ? 'Hide' : 'Show'} Chart
            </button>
          </div>
        </div>

        {/* Dealer Chat - Below the game */}
        {showChat && (
          <div className="bg-white rounded-lg p-4 mt-6 shadow-lg">
            <h3 className="font-bold mb-3 text-gray-800">ðŸŽ² Ask the Dealer</h3>
            
            {isMobile ? (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-sm text-blue-900">
                <div className="font-semibold mb-2">ðŸ’¡ Dealer Chat Not Available on Mobile</div>
                <p className="mb-2">The dealer chat feature requires the desktop version of Claude.ai to work properly.</p>
                <p className="text-xs text-blue-700">All other features (strategy training, split hands, decision tracking) work perfectly on mobile!</p>
              </div>
            ) : (
              <>
                {/* Message display area - always visible */}
                <div className="border border-gray-200 rounded-lg bg-gray-50 p-3 mb-3 min-h-32 max-h-96 overflow-y-auto space-y-3">
                  {chatMessages.length === 0 && !isLoadingChat && (
                    <p className="text-gray-400 text-sm italic">
                      Dealer's advice will appear here. Ask about the current hand or strategy!
                    </p>
                  )}
                  {chatMessages.map((msg, idx) => (
                    <div key={idx} className={`p-3 rounded-lg ${
                      msg.role === 'user'
                        ? 'bg-blue-100 text-blue-900 ml-6'
                        : 'bg-white border border-gray-200 text-gray-900 mr-6'
                    }`}>
                      <div className="text-xs font-bold mb-1 uppercase tracking-wide text-gray-500">
                        {msg.role === 'user' ? 'You' : 'ðŸŽ° Dealer'}
                      </div>
                      <div className="text-sm leading-relaxed whitespace-pre-wrap">{msg.content}</div>
                    </div>
                  ))}
                  {isLoadingChat && (
                    <div className="bg-white border border-gray-200 text-gray-900 mr-6 p-3 rounded-lg">
                      <div className="text-xs font-bold mb-1 uppercase tracking-wide text-gray-500">ðŸŽ° Dealer</div>
                      <div className="text-sm text-gray-400 italic">Shuffling thoughts...</div>
                    </div>
                  )}
                </div>

                {/* Input row */}
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={chatInput}
                    onChange={(e) => setChatInput(e.target.value)}
                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleChatSubmit(); }}}
                    placeholder="e.g., What's the book say here?"
                    disabled={isLoadingChat}
                    className="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-100 text-sm"
                  />
                  <button
                    onClick={handleChatSubmit}
                    disabled={isLoadingChat || !chatInput.trim()}
                    className="px-5 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 text-white rounded-lg transition font-medium text-sm"
                  >
                    Ask
                  </button>
                </div>
              </>
            )}
          </div>
        )}
      </div>
    </div>
  );
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<BlackjackTrainer />);
  </script>
</body>
</html>